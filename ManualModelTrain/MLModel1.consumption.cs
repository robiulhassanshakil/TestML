// This file was auto-generated by ML.NET Model Builder.

using Microsoft.ML;
using Microsoft.ML.Data;
using System;
using System.Linq;
using System.IO;
using System.Collections.Generic;
using Microsoft.ML.Transforms.TimeSeries;
using System.Data;

namespace ManualModelTrain
{
    public partial class MLModel1
    {
        /// <summary>
        /// model input class for MLModel1.
        /// </summary>
        #region model input class
        public class ModelInput
        {
            [LoadColumn(1)]
            [ColumnName(@"energy_use")]
            public float Energy_use { get; set; }

        }

        #endregion

        /// <summary>
        /// model output class for MLModel1.
        /// </summary>
        #region model output class
        public class ModelOutput
        {
            [ColumnName(@"energy_use")]
            public float[] Energy_use { get; set; }

            [ColumnName(@"energy_use_LB")]
            public float[] Energy_use_LB { get; set; }

            [ColumnName(@"energy_use_UB")]
            public float[] Energy_use_UB { get; set; }

        }

        #endregion

        private static string MLNetModelPath = Path.GetFullPath(@"D:\Office Code\SJ\Microsoft_ML_DotNet\TestML\ManualModelTrain\MLModels\TestModelName1.mlnet");

        public static readonly Lazy<TimeSeriesPredictionEngine<ModelInput, ModelOutput>> PredictEngine = new Lazy<TimeSeriesPredictionEngine<ModelInput, ModelOutput>>(() => CreatePredictEngine(), true);

        /// <summary>
        /// Use this method to predict on <see cref="ModelInput"/>.
        /// </summary>
        /// <param name="input">model input.</param>
        /// <returns><seealso cref=" ModelOutput"/></returns>
        public static ModelOutput Predict(ModelInput? input = null, int? horizon = null)
        {
            var predEngine = PredictEngine.Value;
            return predEngine.Predict(input, horizon, confidenceLevel:.95f);
        }

        private static TimeSeriesPredictionEngine<ModelInput, ModelOutput> CreatePredictEngine()
        {
            var mlContext = new MLContext();
            ITransformer mlModel = mlContext.Model.Load(MLNetModelPath, out var schema);
            return mlModel.CreateTimeSeriesEngine<ModelInput, ModelOutput>(mlContext);
        }

        public static void Evaluate()
        {

            string inputDataFilePath = RetrainFilePathTest;
            char separatorChar = RetrainSeparatorChar;
            bool hasHeader = RetrainHasHeader;
            bool allowQuoting = RetrainAllowQuoting;

            var mlContext = new MLContext();
            ITransformer model = mlContext.Model.Load(MLNetModelPath, out var schema);

            var data = LoadIDataViewFromFile(mlContext, inputDataFilePath, separatorChar, hasHeader, allowQuoting);

            IDataView testData = mlContext.Data.FilterRowsByColumn(data, "energy_use");

            IDataView predictions = model.Transform(testData);

            IEnumerable<float> actual = mlContext.Data
                                .CreateEnumerable<ModelInput>(testData, true)
                                .Select(observed => observed.Energy_use);

            IEnumerable<float> forecast = mlContext.Data
                .CreateEnumerable<ModelOutput>(predictions, true)
                .Select(prediction => prediction.Energy_use[0]);


            var metrics = actual.Zip(forecast, (actualValue, forecastValue) => actualValue - forecastValue);

            var MAE = metrics.Average(error => Math.Abs(error)); // Mean Absolute Error
            var RMSE = Math.Sqrt(metrics.Average(error => Math.Pow(error, 2))); // Root Mean Squared Error


            Console.WriteLine("Evaluation Metrics");
            Console.WriteLine("---------------------");
            Console.WriteLine($"Mean Absolute Error: {MAE:F3}");
            Console.WriteLine($"Root Mean Squared Error: {RMSE:F3}\n");

            // Convert to lists for easier iteration
            List<float> actualList = actual.ToList();
            List<float> forecastList = forecast.ToList();

            // Ensure both lists have the same count
            int count = Math.Min(actualList.Count, forecastList.Count);

            // Print actual and forecast values side by side
            Console.WriteLine("Actual vs Forecast:");
            Console.WriteLine("-------------------");
            for (int i = 0; i < count; i++)
            {
                Console.WriteLine($"Actual: {actualList[i]}, Forecast: {forecastList[i]}");
            }
        }
    }
}

